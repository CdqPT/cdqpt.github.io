---
title: Ucos-II学习笔记
author: 陈德强
date: 2019-04-13 14:20:00
categories: 笔记
tags: 嵌入式
toc: true
top: false
img: /medias/paperimg/mcu.jpg
summary: STM32学习笔记
---

转载自：[https://blog.csdn.net/overflyme/article/details/51434336](https://blog.csdn.net/overflyme/article/details/51434336)

# 第一篇 UCOS介绍
## UCOS介绍
这个大家都知道。呵呵。考虑到咱们学习的完整性还是在这里唠叨一下。让大家再熟悉一下。高手们忍耐一下吧！ uC/OS II(Micro Control Operation System Two)是一个可以基于ROM运行的、可裁减的、抢占式、实时多任务内核，具有高度可移植性，特别适合于微处理器和控制器，是和很多商业操作系统性能相当的实时操作系统(RTOS)。为了提供最好的移植性能，uC/OS II最大程度上使用ANSI C语言进行开发，并且已经移植到近40多种处理器体系上，涵盖了从8位到64位各种CPU(包括DSP)。 　　

uC/OS II可以简单的视为一个多任务调度器，在这个任务调度器之上完善并添加了和多任务操作系统相关的系统服务，如信号量、邮箱等。其主要特点有公开源代码，代码结构清晰、明了，注释详尽，组织有条理，可移植性好，可裁剪，可固化。内核属于抢占式，最多可以管理60个任务。

μC/OS-II 的前身是μC/OS，最早出自于1992 年美国嵌入式系统专家Jean J.Labrosse 在《嵌入式系统编程》杂志的5 月和6 月刊上刊登的文章连载，并把μC/OS 的源码发布在该杂志的B S 上。 　　

μC/OS 和μC/OS-II 是专门为计算机的嵌入式应用设计的， 绝大部分代码是用C语言编写的。CPU 硬件相关部分是用汇编语言编写的、总量约200行的汇编语言部分被压缩到最低限度，为的是便于移植到任何一种其它的CPU 上。用户只要有标准的ANSI 的C交叉编译器，有汇编器、连接器等软件工具，就可以将μC/OS-II嵌人到开发的产品中。μC/OS-II 具有执行效率高、占用空间小、实时性能优良和可扩展性强等特点， 最小内核可编译至 2KB 。μC/OS-II 已经移植到了几乎所有知名的CPU 上。 　　

严格地说uC/OS-II只是一个实时操作系统内核，它仅仅包含了任务调度，任务管理，时间管理，内存管理和任务间的通信和同步等基本功能。没有提供输入输出管理，文件系统，网络等额外的服务。但由于uC/OS-II良好的可扩展性和源码开放，这些非必须的功能完全可以由用户自己根据需要分别实现。

uC/OS-II目标是实现一个基于优先级调度的抢占式的实时内核，并在这个内核之上提供最基本的系统服务，如信号量，邮箱，消息队列，内存管理，中断管理等。

uC/OS-II以源代码的形式发布，但并不意味着它是开源软件。你可以将其用于教学和私下研究（peaceful research）；但是如果你将其用于商业用途，那么你必须通过Micrium获得商用许可。

虽然uCOS-II在商业上使用时需要的得到授权并且费用也是一笔不小的数字，但是他的开源毕竟带领我们走入了内核的世界。在此我代表嵌入式工程师向Mr Jean J.Labrosse 致谢。

## 任务管理
uC/OS-II 中最多可以支持64 个任务，分别对应优先级0～63，其中0 为最高优先级。63为最低级，系统保留了4个最高优先级的任务和4个最低优先级的任务，所有用户可以使用的任务数有56个。 　　

uC/OS-II提供了任务管理的各种函数调用，包括创建任务，删除任务，改变任务的优先级，任务挂起和恢复等。 　　

系统初始化时会自动产生两个任务：一个是空闲任务，它的优先级最低，该任务仅给一个整形变量做累加运算；另一个是系统任务，它的优先级为次低，该任务负责统计当前cpu的利用率。

在系统初始化完毕后启动任务时必须创建一份用户任务，也就是说必须有一个应用程序（用户任务，使用应用程序对于我们经常使用Windows用户容易接受一些。呵呵），否则系统会崩溃。当然还有一些其他的要求，咱们后续再说，下面简要概述一下任务管理相关的函数

1.建立任务OSTaskCreat()/OSTaskCreatExt()
如果想让UCOS管理用户的任务，必须先建立任务。可以通过将任务的地址和其他参数传递到以下两个函数之一来建立任务。当调用OSTaskCreat()时，需要四个参数：
OSTaskCreate(void(*task)(void*pd),void*pdata,OS_STK*ptos,INTU prio)
Task：是指向任务代码的指针，pdata：是任务开始执行是，传递给任务的参数的指针，ptos：是分配给任务的堆栈的栈顶指针，prio是分配给任务的优先级。
也可以用OSTaskCreatExt()，不过该函数需要9个参数，前四个参数与OSTaskCreat()一样，例如：
```
INT8U OSTaskCreateExt(void(*task)(void *pd),void *pdata,OS_STK *ptos, INT8U prio, INT16U   id, OS_STK  *pbos, OS_STK  *pbos, OS_STK  *pbos, INT16U  opt)
```
id参数为要建立的任务创建一个特殊的标识符。pbos是指向任务的堆栈栈底的指针，用于堆栈的检验。stk_size用于指定堆栈成员数目的容量。pext是指向用户附加的数据域的指针，用来扩展任务的OS_TCB。opt用于设定OSTaskCreateExt()的选项，指定是否允许堆栈检验，是否将堆栈清零，任务是否要进行浮点操作等等。
2.任务堆栈OS_STK（）
每个任务都有自己的堆栈，堆栈必须申明为OS_STK类型，并且由连续的内存空间组成。可以静态分配堆栈空间，也可以动态分配堆栈空间。
3.堆栈检验OSTaskStkChk()
有时确定任务实际需要的堆栈空间的大小是很有必要的，因为这样就可以避免为任务分配过多的堆栈空间，从而减少应用程序代码所需的RAM空间。
4.删除任务OSTaskDel()
有时需要删除任务，删除任务，是说任务返回并处于休眠态，并不是说任务的代码被删除了，只是任务的代码不再被UCOS调用。删除任务前应保证所删任务并非空闲任务。
5.请求删除任务OSTaskDelReq()
有时，任务会占用一些内存缓冲或信号量一类的资源。这时，假如另一个任务试图删除该任务，这些被占用的资源就会因为没有被释放而丢失。在这种情况下，需想办法拥有这些资源的任务在使用完资源后先释放资源，再删除自己。
6.改变任务的优先级OSTaskChangePrio()
在建立任务时，会分配给任务一个优先级。在程序运行期间，可以通过调用该函数改变任务的优先级。也就是说，UCOS允许动态的改变任务的优先级。
7.挂起任务OSTaskSuspend()
任务挂起是一个附加功能，也就是说，如果任务在被挂起的同时也在等待延迟时间到，那么，需要对任务做取消挂起的操作，并且等待延迟时间到，任务才能转让就绪状态。任务可以挂起自己或者其他任务。
8.恢复任务OSTaskResume()
挂起的任务只有通过该函数才能被恢复。
9.获得任务的信息OSTaskQuery()
通过调用该函数，来获得自身或其他应用任务的信息。

## 时间管理
uC/OS-II的时间管理是通过定时中断来实现的，该定时中断一般为10毫秒或100毫秒发生一次（这个时间片段是OS的作者推荐的，大家可以参考邵贝贝翻译的《嵌入式实时操作系统ucos-II》这本书），时间频率取决于用户对硬件系统的定时器编程来实现。中断发生的时间间隔是固定不变的，该中断也成为一个时钟节拍。这里隐含的意思就是你选择的芯片如果想使用UCOS系统，前提条件一定要有一个Timer。 　　
uC/OS-II要求用户在定时中断的服务程序中，调用系统提供的与时钟节拍相关的系统函数，例如中断级的任务切换函数，系统时间函数。
uCOS时间管理的相关函数
1：任务延迟函数OSTimeDly()
Ucos提供一个可以被任务调用而将任务延时一段特定时间的功能函数，即OSTimeDly().任务调用OSTimeDly()后，一旦规定的时间期满或者有其他的任务通过调用OSTimeDlyResume()取消了延时，他就会进入就绪状态。只有当该任务在所有就绪态任务中具有最高的优先级，它才会立即运行。
2：按时，分，秒延时函数OSRimeDLyHMSM()
与OSTimeDly()一样，调用OSRimeDlyHMSM()函数也会是UCOS进行一次任务调度，并且执行下一个优先级最高的就绪任务。当OSTimeDlyHMSM()后，一旦规定的时间期满，或者有OSTimeDlyResume()，它就会马上处于就绪态。同样，只有当该任务在所有就绪态任务中具有最高的优先级，他才开始运行。
3：恢复延时的任务OSTimeDlyResume()
延时的任务可以不等待延时的期满，而是通过其他任务取消延时而使自己处于就绪态，可以通过该函数来实现，实际上，OSTimeDlyResume()也可以唤醒正在等待的事件。
4：系统时间OSTimeGet()和OSTimeSet()

## 内存管理
在ANSI C中是使用malloc和free两个函数来动态分配和释放内存。例如在Linux系统中就是这样。但在嵌入式实时系统中，多次这样的操作会导致内存碎片，因为嵌入式系统尤其是uCOS是实地址模式，这种模式在分配任务堆栈时需要整块连续的空间，否则任务无法正确运行。且由于内存管理算法的原因，malloc和free的执行时间也是不确定。这点是实时内核最大的矛盾。

基于以上的原因uC/OS-II中把连续的大块内存按分区管理。每个分区中包含整数个大小相同的内存块，但不同分区之间的内存快大小可以不同。用户需要动态分配内存时，系统选择一个适当的分区，按块来分配内存。释放内存时将该块放回它以前所属的分区，这样能有效解决碎片问题，同时执行时间也是固定的。

同时uCOS-II根据以上的处理封装了适合于自己的动态内存分配函数OSMemGet（）和OSMemPut（），但是使用这两个函数动态分配内存前需要先创建内存空间，也就是第二段咱们介绍的内存分块。呵呵，不罗嗦了，具体的关于内存管理的函数如下：

内存控制块的数据结构
```
Typedef
struct
{void   *osmemaddr    ;指向内存分区起始地址的指针。
Void   *osmemfreelist  ;指向下一个空余内存控制块或者下一个空余内存块的指针，
Int32u  osmemblksize  ;内存分区中内存块的大小，是建立内存分区时定义的。
Int32u osmemnblks     ;内存分区中总的内存块数量，也是建立该内存分区时定义的。
Int32u  osmemnfree    ;内存分区块中当前获得的空余块数量。
}os_mem;
```
1；建立一个内存分区，OSMemCreate()
2：分配一个内存块，OSMemGet()
应用程序通过调用该函数，从已经建立的内存分区中申请一个内存块。该函数唯一的参数是指向特定内存分区的指针。
3：释放一个内存块，OSMemPut()
当应用程序不再使用一个内存块时，必须及时的把它释放，并放回到相应的内存分区中，这个操作就是通过调用该函数实现的。
4：查询一个内存分区的状态，OSQMemQuery()。

## 任务间通信与同步
对一个多任务的操作系统来说，任务间的通信和同步是必不可少的。uC/OS-II中提供了4种同步对象，分别是信号量，邮箱，消息队列和事件。所有这些同步对象都有创建，等待，发送，查询的接口用于实现进程间的通信和同步。
对于这4种同步对象将在后面一一讨论。

## 任务调度
uC/OS-II 采用的是可剥夺型实时多任务内核。可剥夺型的实时内核在任何时候都运行就绪了的最高优先级的任务。
uC/os-II的任务调度是完全基于任务优先级的抢占式调度，也就是最高优先级的任务一旦处于就绪状态，则立即抢占正在运行的低优先级任务的处理器资源。为了简化系统设计，uC/OS-II规定所有任务的优先级不同，因为任务的优先级也同时唯一标志了该任务本身。
UCOS的任务调度在一下情况下发生：
1） 高优先级的任务因为需要某种临界资源，主动请求挂起，让出处理器，此时将调度就绪状态的低优先级任务获得执行，这种调度也称为任务级的上下文切换。
2） 高优先级的任务因为时钟节拍到来，在时钟中断的处理程序中，内核发现高优先级任务获得了执行条件(如休眠的时钟到时)，则在中断态直接切换到高优先级任务执行。这种调度也称为中断级的上下文切换。
这两种调度方式在uC/OS-II的执行过程中非常普遍，一般来说前者发生在系统服务中，后者发生在时钟中断的服务程序中。
调度工作的内容可以分为两部分：最高优先级任务的寻找和任务切换。其最高优先级任务的寻找是通过建立就绪任务表来实现的。u C / O S 中的每一个任务都有独立的堆栈空间，并有一个称为任务控制块TCB(Task Control Block)的数据结构，其中第一个成员变量就是保存的任务堆栈指针。任务调度模块首先用变量OSTCBHighRdy 记录当前最高级就绪任务的TCB 地址，然后调用OS_TASK_SW()函数来进行任务切换。

# 第二章 搭建UCOS-II 2.52版的调试平台

在这一章中我们主要讨论UCOSII的源码调试环境，为了给大家一个共同的学习平台，我搜集整理了一写资料，就是以X86为平台，使用BC31（这个堪称骨灰级的编译器）来调试UCOSII源码。当然你也可以用BC45或更高版本的编译器，具体方法大同小异，我在此就不再啰嗦。

本章节的主要内容包括四点：

1、下载并安装BC31编译器

2、下载并安装UCOS-II2.52版本源代码

3、使用BC31编译UCOS-II源码

4、让OS的第一个任务RUN起来

接下来会在每个帖子中讨论一点。耐心等待哦！
## 下载并安装BC31编译器
我在这里提供给大家这个骨灰级的编译器BC31.需要的可以下载。见附件（骨灰级编译器BC31）由于这个软件的比较大，分成两个压缩包。下班了，先到这里，回家再传附件！
## 让自己的第一个任务Run起来
前面已经给大家介绍了如何在PC机上调试UCOS，方法和需要的软件都介绍给大家了，相信有兴趣的朋友已经安装调试了，下面咱们就让自己的第一个任务在PC上Run起来。

OK，下面我就分步介绍建立自己的第一个任务

第一步：CopyC:\SOFTWARE\uCOS-II目录下的EX1_x86L文件夹。作为我们的工程模板

第二步：修改工程模板的名字为：HelloEEWorld

第三部：按照咱们前面的《使用 BC31 工具编译 UCOS‐II 的源码过程 》修改配置文件；

第四步：修改Test.c文件，建立自己的第一个任务

具体的内容我就不再帖子上写了。大家可以参考附件HelloEEWorld.rar里面的Test.c文件。然后编译
## 关于UCOS任务的理解
UCOS的运行是基于任务运行的，为了能够好的使用UCOS我们先要对UCOS的任务的概念做一个理解

在学习ＵＣＯＳ任务前我们先对我们以前使用的模式做一个回顾－－前后台模式。

![image](https://ws2.sinaimg.cn/large/006jQClrly1g20zsc9trqj30dv08hdh4.jpg)
这种系统可称为前后台系统或超循环系统(Super-Loops)。应用程序是一个无限的循环，循环中调用相应的函数完成相应的操作，这部分可以看成后台行为(background)。中断服务程序处理异步事件，这部分可以看成前台行 foreground。后台也可以叫做任务级。前台也叫中断级。时间相关性很强的关键操作(Critical operation)一定是靠中断服务来保证的。因为中断服务提供的信息一直要等到后台程序走到该处理这个信息这一步时才能得到处理，这种系统在处理信息的及时性上，比实际可以做到的要差。这个指标称作任务级响应时间。最坏情况下的任务级响应时间取决于整个循环的执行时间。因为循环的执行时间不是常数，程序经过某一特定部分的准确时间也是不能确定的。进而，如果程序修改了，循环的时序也会受到影响。

这种系统是在我们上学时和做小项目时经常用到，很多工程师称这种方式为“裸奔”。哈哈！我大学毕业后的钱三年写的项目都是在裸奔。

UCOS-II是基于任务运行的。一个任务，也称作一个线程，是一个简单的程序，该程序可以认为 CPU 完全只属该程序自己。实时应用程序的设计过程，包括如何把问题分割成多个任务，每个任务都是整个应用的某一部分，每个任务被赋予一定的优先级，有它自己的一套 CPU 寄存器和自己的栈空间(如下图所示)。
![image](https://wx3.sinaimg.cn/large/006jQClrly1g20zsy067cj30gd0gn411.jpg)
可以这么理解，UCOS-II的每一个任务都有一个CPU，任务在运行时占用CPU的全部资源，同时拥有自己的一套寄存器，当任务执行完毕后（时间片到），他把自己的CPU寄存器所有内容保存到自己的堆栈中，同时把CPU让给别的任务，那么得到CPU使用权的任务把自己的CPU寄存器从自己的堆栈中放到真正的CPU寄存器中开始运行，就这样周而复始。

大家一定不要把任务的运行当成是函数的调用，这完全是两回事。这个我们到后面的任务调度时在细说。每个任务都是一个无限的循环。每个任务都处在以下 5种状态之一的状态下，这5种状态是休眠态， 就绪态、 运行态、 挂起态(等待某一事件发生)和被中断态（参见下图）   休眠态相当于该任务驻留在内存中，但并不被多任务内核所调度。就绪意味着该任务已经准备好， 可以运行了， 但由于该任务的优先级比正在运行的任务的优先级低， 还暂时不能运行。运行态的任务是指该任务掌握了 CPU 的控制权，正在运行中。挂起状态也可以叫做等待事件态WAITING，指该任务在等待，等待某一事件的发生， （例如等待某外设的 I/O 操作，等待某共享资源由暂不能使用变成能使用状态， 等待定时脉冲的到来或等待超时信号的到来以结束目前的等待，等等） 。最后，发生中断时，CPU提供相应的中断服务，原来正在运行的任务暂不能运行，就进入了被中断状态。如下图表示μC/OS-Ⅱ中一些函数提供的服务，这些函数使任务从一种状态变到另一种状态。
![image](https://wx3.sinaimg.cn/large/006jQClrly1g20ztfqjaej30h209gjua.jpg)
简单的我们可以把每一次任务的切换当成一次中断，这个中断不同于我们在使用前后台模式时的中断，那个中断是硬件中断，中断时需要保存的CPU寄存器是由硬件实现的，而在UCOS中的任务切换是软中断，CPU保存了必要的寄存器后在切换时系统会在保存任务使用的寄存器。
## 补充知识-可剥夺型内核和不可剥夺型内核
不可剥夺型内核

不可剥夺型内核要求每个任务自我放弃CPU 的所有权。 不可剥夺型调度法也称作合作型多任务，各个任务彼此合作共享一个 CPU。异步事件还是由中断服务来处理。中断服务可以使一个高优先级的任务由挂起状态变为就绪状态。 但中断服务以后控制权还是回到原来被中断了的那个任务，直到该任务主动放弃 CPU 的使用权时，那个高优先级的任务才能获得 CPU的使用权。

不可剥夺型内核允许每个任务运行，直到该任务自愿放弃 CPU的控制权。中断可以打入运行着的任务。 中断服务完成以后将 CPU 控制权还给被中断了的任务。任务级响应时间要大大好于前后系统，但仍是不可知的，商业软件几乎没有不可剥夺型内核。

不可剥夺型内核的工作过程见下图：
