---
title: 关联容器
author: 陈德强
date: 2019-09-25 22:10:00
categories:
- 字典
tags:
- CPlus
toc: true
top: false
img: /medias/paperimg/c.jpg
summary: 关联容器总结。
---

关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。但是关联式容器提供了另一种根据元素特点排序的功能，这样迭代器就能根据元素的特点“顺序地”获取元素。元素是有序的集合，默认在插入的时候按升序排列。

关联容器包括：map（集合）、set（映射）、multimap（多重集合）、multiset（多重映射）。
# 一、map

map容器提供一个键值对（key/value）容器，map与multimap差别仅仅在于multiple允许一个键对应多个值。对于迭代器来说，可以修改实值，而不能修改key。Map会根据key自动排序。
map 是键－值对的集合。map 类型通常可理解为关联数组：可使用键作为下标来获取一个值，正如内置数组类型一样。而关联的本质在于元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取。

## 1 1 初始化
```c
#include <map>
```
```c
map<k, v>m        //创建一个名为m的空map对象，其键和值的类型分别为k和v
map<k, v>m(m2)    //创建m2的副本m，m与m2必须有相同的键类型和值类型
map<k, v>m(b, e)  //创建map类型的对象m，存储迭代器b和e标记的范围内所有元素的副本,
                  //元素的类型必须能转换为pair<const k, v>。
```
在使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。所用的比较函数必须在键类型上定义严格弱排序（strict weak ordering）：可理解为键类型数据上的“小于”关系，虽然实际上可以选择将比较函数设计得更复杂。对于键类型，唯一的约束就是必须支持 < 操作符，至于是否支持其他的关系或相等运算，则不作要求。

## 1 2 方法
添加元素有两种方法：1、先用下标操作符获取元素，然后给获取的元素赋值 2、使用insert成员函数实现
下标操作添加元素：如果该键已在容器中，则 map 的下标运算与 vector 的下标运算行为相同：返回该键所关联的值。只有在所查找的键不存在时，map 容器才为该键创建一个新的元素，并将它插入到此 map 对象中。此时，所关联的值采用值初始化：类类型的元素用默认构造函数初始化，而内置类型的元素初始化为 0。

```c
m insert(e)    //e是一个用在m上的value_type 类型的值。如果键（e first不在m中，则插入一个值为e second 
               //的新元素；如果该键在m中已存在，则保持m不变。该函数返回一个pair类型对象，包含指向键为
               //e first的元素的map迭代器，以及一个 bool 类型的对象，表示是否插入了该元素
-------------------------------------------------------------------------------------------
m insert(beg,end)//beg和end是标记元素范围的迭代器，其中的元素必须为m value_type 类型的键－值对。对于
                 //该范围内的所有元素，如果它的键在m中不存在，则将该键及其关联的值插入到m。返回void类型
-------------------------------------------------------------------------------------------
m insert(iter,e)//e是一个用在m上的 value_type 类型的值。如果键（e first）不在m中，则创建新元素，并以
                //迭代器iter为起点搜索新元素存储的位置。返回一个迭代器，指向m中具有给定键的元素
```

## 1 3 遍历
map中使用下标存在一个很危险的副作用：如果该键不在 map 容器中，那么下标操作会插入一个具有该键的新元素。所以map 容器提供了两个操作：count 和 find，用于检查某个键是否存在而不会插入该键。
```c
m count(k)   //返回 m 中 k 的出现次数
m find(k)    //如果m容器中存在按k索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器。
```

## 1 4 删除
```c
m erase(k)      //删除m中键为k的元素。返回size_type类型的值，表示删除的元素个数
m erase(p)      //删除p所指向的元素。p必须指向m中确实存在的元素，而且不能等于m end()。返回void
m erase(b,e)    //从m中删除一段范围内的元素，该范围由迭代器对b和e标记。b和e必须标记m中的一段有效范围：即b和e都必须指向m中的元素或最后一个元素的下一个位置。而且，b和e要么相等（此时删除的范围为空），要么b所指向的元素必须出在e所指向的元素之前。返回 void 类型
```

# 二、set
set的含义是集合，它是一个有序的容器，里面的元素都是排序好的，支持插入，删除，查找等操作，就像一个集合一样。所有的操作的都是严格在logn时间之内完成，效率非常高。set和multiset的区别是：set插入的元素不能相同，但是multiset可以相同。Set默认自动排序。使用方法类似list。

```c
begin()              //返回指向第一个元素的迭代器
clear()              //清除所有元素
count()              //返回某个值元素的个数
empty()              //如果集合为空，返回true
end()                //返回指向最后一个元素的迭代器
equal_range()        //返回集合中与给定值相等的上下限的两个迭代器
erase()              //删除集合中的元素
find()               //返回一个指向被查找到元素的迭代器
get_allocator()      //返回集合的分配器
insert()             //在集合中插入元素
lower_bound()        //返回指向大于（或等于）某值的第一个元素的迭代器
key_comp()           //返回一个用于元素间值比较的函数
max_size()           //返回集合能容纳的元素的最大限值
rbegin()             //返回指向集合中最后一个元素的反向迭代器
rend()               //返回指向集合中第一个元素的反向迭代器
size()               //集合中元素的数目
swap()               //交换两个集合变量
upper_bound()        //返回大于某个值元素的迭代器
value_comp()         //返回一个用于比较元素间的值的函数
```
举个栗子：
```c
#include<set>
#include<iostream>
using namespace std;
int main()
{
    int i;
    int arr[5] = {0,1,2,3,4};
    set<int> iset(arr,arr+5);

    iset insert(5);
    cout<<"size:"<<iset size()<<endl;
    cout<<"3 count = "<<iset count(3)<<endl;
    iset erase(1);

    set<int>::iterator ite1 = iset begin();
    set<int>::iterator ite2 = iset end();
    for(;ite1!=ite2;ite1++)
    {
        cout<<*ite1;
    }
    cout<<endl;

    ite1 = iset find(3);
    if(ite1!=iset end())
        cout<<"3 found"<<endl;

    ite1 = iset find(1);
    if(ite1!=iset end())
        cout<<"1 not found"<<endl;
}
```


参考链接：
https://blog csdn net/u014465639/article/details/70241850